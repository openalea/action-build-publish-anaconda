name: 'build-publish-anaconda'
description: 'Build and Publish anaconda package'
author: 'Thomas Arsouze'
branding:
  icon: 'package'
  color: 'green'
inputs:
  os_name:
    description: 'The name of the os the action is called on (eg ubuntu-latest)'
    required: false
    default: 'unknown'
  conda:
    description: "Directory with conda recipe. Default `.` ."
    required: false
    default: '.'
  condapython:
    description: 'Python3 minor version used for installing conda-build.'
    required: false
    default: '13'
  python:
    description: 'Python3 minor version targeted by build.'
    required: false
    default: '13'
  token:
    description: 'Anaconda access Token (required)'
    required: true
  channels:
    description: 'Optional Extra anaconda channels to use. Coma-separated syntax. Default `conda-forge`.'
    required: false
    default: 'conda-forge'
  upload_artifact:
    description: 'Whether the package build should be upload as an artifact on GitHub'
    required: false
    default: 'false'
  publish:
    description: 'Whether we publish the package build on anaconda cloud or not.'
    required: false
    default: 'true'
  publish_if_py:
    description: "Publish only if build_py belongs to this list of python minor versions. Passing empty list means ignore this test"
    required: false
    default: '[]'
  publish_if_os:
    description: "Publish only if build_os belongs to this list of os. Passing empty list means ignore this test."
    required: false
    default: '[]'
  label:
    description: 'Label of conda package published'
    required: false
    default: 'main'
  build-options:
    description: 'Build options for conda build.'
    required: false
    default: ''
runs:
  using: "composite"
  steps:
    - name: Check if meta.yml exists in ${{ inputs.conda }} directory
      id: check-meta
      working-directory: ./${{ inputs.conda }}
      run: |
        echo "::group::Checking the conda directory if the file meta.yaml exists"
        if [ ! -f meta.yaml ]; then
           echo "A meta.yaml file with the compilation instructions of the conda package was not found in ${{ inputs.conda }}."
           exit 1
        else
           echo "A meta.yaml file with the compilation instructions of the conda package was found in ${{ inputs.conda }}."
        fi
        echo "::endgroup::"
      shell: bash
    - name: Check if anaconda login information are available
      id: check-login
      if: ${{ inputs.publish == 'true' }}
      working-directory: ./${{ inputs.conda }}
      run: |
        echo "::group::Checking if the token variable is correclty set"
        if [[ "${{ inputs.token }}" == "" ]]; then
           echo "No token variable is set for upload."
           exit 1
        else
           echo "Token is correctly set."
        fi
        echo "::endgroup::"
      shell: bash
    - name: Setup Conda environment
      uses: conda-incubator/setup-miniconda@v3
      with:
        python-version: 3.${{ inputs.condapython }}
        channels: ${{ inputs.channels }}
        auto-update-conda: false
        miniforge-version: latest
        conda-remove-defaults: true
        channel-priority: strict
    - name: Setup conda-build
      run: |
        echo "::group::Setup conda-build"
        conda install -q conda-build conda-forge-pinning
        echo "::endgroup::"
      shell: bash -l {0}
    - name: Package building (no test)
      id: package-compilation
      working-directory: ./${{ inputs.conda }}
      run: |
        echo "::group::Conda packages building"
        export PYTHON_VERSION="3.${{ inputs.python }}"
        variants=$(awk '/^python:/{flag=1;next} /^[^[:space:]-]/{flag=0} flag && NF' $CONDA_PREFIX/conda_build_config.yaml)
        echo "Variants founds: $variants"
        export PYTHON_VARIANT=$(echo "$variants" | grep -E "^[[:space:]]*-[[:space:]]*${PYTHON_VERSION}" | sed -E 's/^[[:space:]]*-[[:space:]]*//')
        # Fail if not found
        if [ -z "${PYTHON_VARIANT//[[:space:]]/}" ]; then
          echo "Error: No Python variant found for ${PYTHON_VERSION} in conda_build_config.yaml"
          exit 1
        fi
        CONDA_FORGE_PINNING="${CONDA_PREFIX}/conda_build_config.yaml"
        # If a local conda_build_config.yaml exists next to meta.yaml, rename it
        LOCAL_CONFIG="conda_build_config.yaml"
        if [[ -f "$LOCAL_CONFIG" ]]; then
          RENAMED_LOCAL="local_overrides.yaml"
          mv "$LOCAL_CONFIG" "$RENAMED_LOCAL"
          echo "Detected local config: renamed to $RENAMED_LOCAL"
          EXTRA_M="-m $RENAMED_LOCAL"
        else
          echo "No local conda_build_config.yaml found"
          EXTRA_M=""
        fi
        out_dir=$(mktemp -d "${GITHUB_WORKSPACE}/conda-build-dir.XXXXXX")
        echo "Building Conda package into $out_dir"
        echo "Running 'conda build' with python ${PYTHON_VERSION} and variant ${PYTHON_VARIANT}"
        conda build . --no-test --output-folder "$out_dir" -m "$CONDA_FORGE_PINNING" $EXTRA_M --python "$PYTHON_VARIANT" ${{ inputs.build-options }}
        pkg_path=$(find "$out_dir" -name "*.conda" -type f | head -n1)
        # On Windows, convert the path to native form:
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          pkg_path=$(cygpath -w "$pkg_path")
        fi
        echo "built file: $pkg_path"
        echo "pkg_path=$pkg_path" >> "$GITHUB_OUTPUT"
        echo "upload_artifact: ${{ inputs.upload_artifact }}"
        echo "::endgroup::"
      shell: bash -l {0}
    - name: Upload Conda build artifact
      uses: actions/upload-artifact@v4
      if: ${{ fromJSON(inputs.upload_artifact) }}
      with:
        name: conda-package-py3${{ inputs.python }}-${{ inputs.os_name }}
        path: |
          ${{ steps.package-compilation.outputs.pkg_path }}
        retention-days: 10
    - name: Test built Conda package
      shell: bash -l {0}
      run: |
        echo "::group::Test package"
        conda build --test "${{ steps.package-compilation.outputs.pkg_path }}"
        echo "::endgroup::"
    - name: Determine upload
      id: check-upload
      shell: bash
      run: |
        echo "::group::Determine uploading"
        should_upload=false

        if [[ "${{ inputs.publish }}" == "true" ]]; then
          os_match=false
          py_match=false

          # Check OS list (skip if [])
          if [[ '${{ inputs.publish_if_os }}' == '[]' ]]; then
            os_match=true
          else
            for os in $(echo '${{ inputs.publish_if_os }}' | jq -r '.[]'); do
              if [[ "$os" == "${{ inputs.os_name }}" ]]; then
                os_match=true
              fi
            done
          fi

          # Check Python list (skip if [])
          if [[ '${{ inputs.publish_if_py }}' == '[]' ]]; then
            py_match=true
          else
            for py in $(echo '${{ inputs.publish_if_py }}' | jq -r '.[]'); do
              if [[ "$py" == "${{ inputs.python }}" ]]; then
                py_match=true
              fi
            done
          fi

          if [[ "$os_match" == "true" && "$py_match" == "true" ]]; then
            should_upload=true
          fi
        fi
        echo "should_upload=$should_upload"
        echo "should_upload=$should_upload" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"
    - name: Setup anaconda-client
      if: ${{ steps.check-upload.outputs.should_upload == 'true' }}
      run: |
        echo "::group::Setup anaconda-client"
        conda install -q anaconda-client
        echo "::endgroup::"
      shell: bash -l {0}
    - name: Package uploading
      id: package-uploading
      if: ${{ steps.check-upload.outputs.should_upload == 'true' }}
      run: |
        echo "::group::Conda packages uploading"
        export ANACONDA_API_TOKEN=${{ inputs.token }}
        BUILD_FILE="${{ steps.package-compilation.outputs.pkg_path }}"
        echo "Upload file ${BUILD_FILE} to Anaconda on label ${{ inputs.label }}"
        anaconda upload --force --no-progress --label "${{ inputs.label }}" "${BUILD_FILE}" 
        echo "::endgroup::"
      shell: bash -l {0}
